{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 63, "column": 0}, "map": {"version":3,"sources":["file:///usr/local/darkflows/src/live-ifstat/app/api/sys-stats/route.ts"],"sourcesContent":["import { NextRequest } from 'next/server';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\n\nconst execAsync = promisify(exec);\n\nexport const dynamic = 'force-dynamic';\nexport const runtime = 'nodejs';\n\nexport async function GET(request: NextRequest) {\n  const encoder = new TextEncoder();\n  let intervalId: NodeJS.Timeout | null = null;\n  let isStreamActive = true;\n\n  // Get total memory once at the start\n  let totalMemMB = 0;\n  try {\n    const { stdout } = await execAsync('free -m');\n    const lines = stdout.trim().split('\\n');\n    for (const line of lines) {\n      if (line.startsWith('Mem:')) {\n        const parts = line.split(/\\s+/);\n        totalMemMB = parseInt(parts[1], 10);\n        break;\n      }\n    }\n  } catch (err) {\n    console.error('Error getting total memory:', err);\n  }\n\n  const stream = new ReadableStream({\n    start: async (controller) => {\n      try {\n        // Handle client disconnection\n        request.signal.addEventListener('abort', () => {\n          console.log('Client disconnected from sys-stats, cleaning up');\n          isStreamActive = false;\n          if (intervalId) {\n            clearInterval(intervalId);\n            intervalId = null;\n          }\n          controller.close();\n        });\n\n        // Set up interval for data collection\n        intervalId = setInterval(async () => {\n          if (!isStreamActive) {\n            if (intervalId) {\n              clearInterval(intervalId);\n              intervalId = null;\n            }\n            return;\n          }\n\n          try {\n            // Get memory info\n            const { stdout: memInfo } = await execAsync('free -m');\n            const memLines = memInfo.trim().split('\\n');\n            let freeMB = 0;\n            for (const line of memLines) {\n              if (line.startsWith('Mem:')) {\n                const parts = line.split(/\\s+/);\n                // parts[3] is \"free\", parts[6] is \"available\" (includes cache/buffers)\n                freeMB = parseInt(parts[6], 10); // Use \"available\" instead of \"free\"\n                break;\n              }\n            }\n\n            // Get CPU info - run vmstat with a 1-second delay to get current usage\n            const { stdout: cpuInfo } = await execAsync('vmstat 1 2');\n            const cpuLines = cpuInfo.trim().split('\\n');\n            // Get the last line which contains current stats\n            const cpuStats = cpuLines[cpuLines.length - 1].trim().split(/\\s+/);\n            \n            // Calculate CPU usage from idle percentage\n            // In vmstat output, the 15th column (index 14) is idle CPU percentage\n            const idlePercent = parseInt(cpuStats[14], 10);\n            const cpuUsage = 100 - idlePercent;\n\n            const percentFree = totalMemMB > 0 ? (freeMB / totalMemMB) * 100 : 0;\n\n            const data = {\n              timestamp: new Date().toLocaleTimeString(),\n              cpu: cpuUsage,\n              memFree: freeMB,\n              totalMemMB,\n              percentFree,\n            };\n\n            // Only send data if the stream is still active\n            if (isStreamActive) {\n              try {\n                // Send data\n                controller.enqueue(encoder.encode(`data: ${JSON.stringify(data)}\\n\\n`));\n\n                // Send heartbeat every 30 seconds\n                if (Date.now() % 30000 < 1000) {\n                  controller.enqueue(encoder.encode('event: heartbeat\\ndata: {}\\n\\n'));\n                }\n              } catch (enqueueError) {\n                console.log('Stream closed, stopping sys-stats collection:', enqueueError);\n                isStreamActive = false;\n                if (intervalId) {\n                  clearInterval(intervalId);\n                  intervalId = null;\n                }\n              }\n            }\n          } catch (error) {\n            console.error('Error collecting system stats:', error);\n            if (isStreamActive) {\n              try {\n                controller.enqueue(encoder.encode(`event: error\\ndata: ${JSON.stringify({ error: String(error) })}\\n\\n`));\n              } catch (enqueueError) {\n                console.log('Stream closed during error handling:', enqueueError);\n                isStreamActive = false;\n                if (intervalId) {\n                  clearInterval(intervalId);\n                  intervalId = null;\n                }\n              }\n            }\n          }\n        }, 1000);\n      } catch (error) {\n        console.error('Stream setup error:', error);\n        isStreamActive = false;\n        if (intervalId) {\n          clearInterval(intervalId);\n          intervalId = null;\n        }\n        controller.error(error);\n      }\n    },\n    cancel: () => {\n      console.log('System stats stream cancelled');\n      isStreamActive = false;\n      if (intervalId) {\n        clearInterval(intervalId);\n        intervalId = null;\n      }\n    }\n  });\n\n  return new Response(stream, {\n    headers: {\n      'Content-Type': 'text/event-stream',\n      'Cache-Control': 'no-cache',\n      'Connection': 'keep-alive',\n    }\n  });\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 209, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}