{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 63, "column": 0}, "map": {"version":3,"sources":["file:///usr/local/darkflows/src/live-ifstat/app/api/ifstat-stream/route.ts"],"sourcesContent":["import { NextRequest } from 'next/server';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\n\nconst execAsync = promisify(exec);\n\nexport const dynamic = 'force-dynamic';\nexport const runtime = 'nodejs';\n\nasync function getNetworkStats(device: string) {\n  try {\n    const [rxBytes, txBytes] = await Promise.all([\n      execAsync(`cat /sys/class/net/${device}/statistics/rx_bytes`),\n      execAsync(`cat /sys/class/net/${device}/statistics/tx_bytes`)\n    ]);\n\n    return {\n      rxBytes: parseInt(rxBytes.stdout.trim(), 10),\n      txBytes: parseInt(txBytes.stdout.trim(), 10)\n    };\n  } catch (error) {\n    throw new Error(`Failed to read stats for ${device}: ${error}`);\n  }\n}\n\nexport async function GET(request: NextRequest) {\n  const encoder = new TextEncoder();\n  let intervalId: NodeJS.Timeout | null = null;\n  let isStreamActive = true;\n  const lastStats: { [device: string]: { rxBytes: number; txBytes: number; timestamp: number } } = {};\n\n  // Get list of devices\n  const devices: string[] = [];\n  try {\n    const { stdout } = await execAsync('ls /sys/class/net');\n    devices.push(...stdout.trim().split('\\n').filter(dev => dev !== 'lo'));\n  } catch (err) {\n    console.error('Error getting network devices:', err);\n    return new Response('Failed to get network devices', { status: 500 });\n  }\n\n  const stream = new ReadableStream({\n    start: async (controller) => {\n      try {\n        // Handle client disconnection\n        request.signal.addEventListener('abort', () => {\n          console.log('Client disconnected, cleaning up');\n          isStreamActive = false;\n          if (intervalId) {\n            clearInterval(intervalId);\n            intervalId = null;\n          }\n          controller.close();\n        });\n\n        // Initialize last stats\n        for (const device of devices) {\n          try {\n            const stats = await getNetworkStats(device);\n            lastStats[device] = {\n              ...stats,\n              timestamp: Date.now()\n            };\n          } catch (error) {\n            console.error(`Error initializing stats for ${device}:`, error);\n          }\n        }\n\n        // Set up interval for data collection\n        intervalId = setInterval(async () => {\n          if (!isStreamActive) {\n            if (intervalId) {\n              clearInterval(intervalId);\n              intervalId = null;\n            }\n            return;\n          }\n\n          // Collect data for all devices\n          for (const device of devices) {\n            try {\n              const now = Date.now();\n              const stats = await getNetworkStats(device);\n              const last = lastStats[device];\n\n              if (last) {\n                const timeDiff = (now - last.timestamp) / 1000; // Convert to seconds\n                const rxDiff = stats.rxBytes - last.rxBytes;\n                const txDiff = stats.txBytes - last.txBytes;\n\n                // Calculate KB/s\n                const kbIn = (rxDiff / 1024) / timeDiff;\n                const kbOut = (txDiff / 1024) / timeDiff;\n\n                if (!isNaN(kbIn) && !isNaN(kbOut)) {\n                  const data = {\n                    timestamp: new Date().toLocaleTimeString(),\n                    kbIn,\n                    kbOut,\n                    device\n                  };\n\n                  // Only send data if the stream is still active\n                  if (isStreamActive) {\n                    try {\n                      // Send data\n                      controller.enqueue(encoder.encode(`data: ${JSON.stringify(data)}\\n\\n`));\n                    } catch (error) {\n                      console.log(`Stream closed, stopping data collection:`, error);\n                      isStreamActive = false;\n                      if (intervalId) {\n                        clearInterval(intervalId);\n                        intervalId = null;\n                      }\n                      return;\n                    }\n                  }\n                }\n              }\n\n              // Update last stats\n              lastStats[device] = {\n                ...stats,\n                timestamp: now\n              };\n            } catch (error) {\n              console.error(`Error collecting data for ${device}:`, error);\n              if (isStreamActive) {\n                try {\n                  controller.enqueue(encoder.encode(`event: error\\ndata: ${JSON.stringify({ error: String(error), device })}\\n\\n`));\n                } catch (enqueueError) {\n                  console.log('Stream closed during error handling:', enqueueError);\n                  isStreamActive = false;\n                  if (intervalId) {\n                    clearInterval(intervalId);\n                    intervalId = null;\n                  }\n                  return;\n                }\n              }\n            }\n          }\n\n          // Send heartbeat every 30 seconds\n          if (isStreamActive && Date.now() % 30000 < 1000) {\n            try {\n              controller.enqueue(encoder.encode('event: heartbeat\\ndata: {}\\n\\n'));\n            } catch (enqueueError) {\n              console.log('Stream closed during heartbeat:', enqueueError);\n              isStreamActive = false;\n              if (intervalId) {\n                clearInterval(intervalId);\n                intervalId = null;\n              }\n            }\n          }\n        }, 1000);\n      } catch (error) {\n        console.error('Stream setup error:', error);\n        isStreamActive = false;\n        if (intervalId) {\n          clearInterval(intervalId);\n          intervalId = null;\n        }\n        controller.error(error);\n      }\n    },\n    cancel: () => {\n      console.log('Stream cancelled');\n      isStreamActive = false;\n      if (intervalId) {\n        clearInterval(intervalId);\n        intervalId = null;\n      }\n    }\n  });\n\n  return new Response(stream, {\n    headers: {\n      'Content-Type': 'text/event-stream',\n      'Cache-Control': 'no-cache',\n      'Connection': 'keep-alive',\n    }\n  });\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 242, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}