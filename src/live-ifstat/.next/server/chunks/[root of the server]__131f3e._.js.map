{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 63, "column": 0}, "map": {"version":3,"sources":["file:///usr/local/darkflows/src/live-ifstat/app/api/devices/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\nimport { readFile } from 'fs/promises'\n\ninterface NetworkDevice {\n  type?: 'primary' | 'secondary' | 'internal'\n  label?: string\n  egressBandwidth?: string\n  ingressBandwidth?: string\n}\n\nasync function parseNetworkConfig(): Promise<Record<string, NetworkDevice>> {\n  try {\n    const content = await readFile('/etc/darkflows/d_network.cfg', 'utf-8')\n    const devices: Record<string, NetworkDevice> = {}\n    \n    const lines = content.split('\\n')\n    for (const line of lines) {\n      const trimmed = line.trim()\n      if (trimmed.startsWith('#') || !trimmed) continue\n\n      const match = trimmed.match(/^(\\w+)_(\\w+)=\"([^\"]*)\"/)\n      if (!match) continue\n\n      const [, type, key, value] = match\n      const deviceType = type.toLowerCase() as 'primary' | 'secondary' | 'internal'\n\n      if (key === 'INTERFACE') {\n        devices[value] = {\n          type: deviceType\n        }\n      } else if (key === 'LABEL' && devices[getInterfaceForType(lines, deviceType)]) {\n        devices[getInterfaceForType(lines, deviceType)].label = value\n      } else if (key.endsWith('BANDWIDTH')) {\n        const direction = key.startsWith('EGRESS') ? 'egressBandwidth' : 'ingressBandwidth'\n        const iface = getInterfaceForType(lines, deviceType)\n        if (devices[iface]) {\n          devices[iface][direction] = value\n        }\n      }\n    }\n    \n    return devices\n  } catch (error) {\n    console.error('Error reading network config:', error)\n    return {}\n  }\n}\n\nfunction getInterfaceForType(lines: string[], type: string): string {\n  const interfaceLine = lines.find(line => \n    line.trim().startsWith(`${type.toUpperCase()}_INTERFACE=`)\n  )\n  if (!interfaceLine) return ''\n  \n  const match = interfaceLine.match(/\"([^\"]*)\"/)\n  return match ? match[1] : ''\n}\n\nexport async function GET() {\n  try {\n    const configDevices = await parseNetworkConfig()\n    \n    const devices = Object.entries(configDevices).map(([name, config]) => ({\n      name,\n      ...config\n    }))\n    \n    console.log('Devices API response:', JSON.stringify(devices, null, 2))\n    return NextResponse.json({ devices })\n  } catch (error) {\n    console.error('Error fetching network devices:', error)\n    return NextResponse.json({ devices: [] }, { status: 500 })\n  }\n} "],"names":[],"mappings":";;;AAAA;AACA;;;AASA,eAAe;IACb,IAAI;QACF,MAAM,UAAU,MAAM,CAAA,GAAA,qHAAA,CAAA,WAAQ,AAAD,EAAE,gCAAgC;QAC/D,MAAM,UAAyC,CAAC;QAEhD,MAAM,QAAQ,QAAQ,KAAK,CAAC;QAC5B,KAAK,MAAM,QAAQ,MAAO;YACxB,MAAM,UAAU,KAAK,IAAI;YACzB,IAAI,QAAQ,UAAU,CAAC,QAAQ,CAAC,SAAS;YAEzC,MAAM,QAAQ,QAAQ,KAAK,CAAC;YAC5B,IAAI,CAAC,OAAO;YAEZ,MAAM,GAAG,MAAM,KAAK,MAAM,GAAG;YAC7B,MAAM,aAAa,KAAK,WAAW;YAEnC,IAAI,QAAQ,aAAa;gBACvB,OAAO,CAAC,MAAM,GAAG;oBACf,MAAM;gBACR;YACF,OAAO,IAAI,QAAQ,WAAW,OAAO,CAAC,oBAAoB,OAAO,YAAY,EAAE;gBAC7E,OAAO,CAAC,oBAAoB,OAAO,YAAY,CAAC,KAAK,GAAG;YAC1D,OAAO,IAAI,IAAI,QAAQ,CAAC,cAAc;gBACpC,MAAM,YAAY,IAAI,UAAU,CAAC,YAAY,oBAAoB;gBACjE,MAAM,QAAQ,oBAAoB,OAAO;gBACzC,IAAI,OAAO,CAAC,MAAM,EAAE;oBAClB,OAAO,CAAC,MAAM,CAAC,UAAU,GAAG;gBAC9B;YACF;QACF;QAEA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,OAAO,CAAC;IACV;AACF;AAEA,SAAS,oBAAoB,KAAe,EAAE,IAAY;IACxD,MAAM,gBAAgB,MAAM,IAAI,CAAC,CAAA,OAC/B,KAAK,IAAI,GAAG,UAAU,CAAC,GAAG,KAAK,WAAW,GAAG,WAAW,CAAC;IAE3D,IAAI,CAAC,eAAe,OAAO;IAE3B,MAAM,QAAQ,cAAc,KAAK,CAAC;IAClC,OAAO,QAAQ,KAAK,CAAC,EAAE,GAAG;AAC5B;AAEO,eAAe;IACpB,IAAI;QACF,MAAM,gBAAgB,MAAM;QAE5B,MAAM,UAAU,OAAO,OAAO,CAAC,eAAe,GAAG,CAAC,CAAC,CAAC,MAAM,OAAO,GAAK,CAAC;gBACrE;gBACA,GAAG,MAAM;YACX,CAAC;QAED,QAAQ,GAAG,CAAC,yBAAyB,KAAK,SAAS,CAAC,SAAS,MAAM;QACnE,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE;QAAQ;IACrC,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,mCAAmC;QACjD,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,SAAS,EAAE;QAAC,GAAG;YAAE,QAAQ;QAAI;IAC1D;AACF"}},
    {"offset": {"line": 128, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}