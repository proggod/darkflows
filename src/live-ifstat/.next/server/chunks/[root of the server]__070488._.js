module.exports = {

"[externals]/next/dist/compiled/next-server/app-route.runtime.dev.js [external] (next/dist/compiled/next-server/app-route.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
const mod = __turbopack_external_require__("next/dist/compiled/next-server/app-route.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
const mod = __turbopack_external_require__("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page.runtime.dev.js [external] (next/dist/compiled/next-server/app-page.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
const mod = __turbopack_external_require__("next/dist/compiled/next-server/app-page.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
const mod = __turbopack_external_require__("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
const mod = __turbopack_external_require__("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/child_process [external] (child_process, cjs)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
const mod = __turbopack_external_require__("child_process", () => require("child_process"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
const mod = __turbopack_external_require__("util", () => require("util"));

module.exports = mod;
}}),
"[project]/app/api/ifstat-stream/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "GET": (()=>GET),
    "dynamic": (()=>dynamic),
    "runtime": (()=>runtime)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$child_process__$5b$external$5d$__$28$child_process$2c$__cjs$29$__ = __turbopack_import__("[externals]/child_process [external] (child_process, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$util__$5b$external$5d$__$28$util$2c$__cjs$29$__ = __turbopack_import__("[externals]/util [external] (util, cjs)");
;
;
const execAsync = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$util__$5b$external$5d$__$28$util$2c$__cjs$29$__["promisify"])(__TURBOPACK__imported__module__$5b$externals$5d2f$child_process__$5b$external$5d$__$28$child_process$2c$__cjs$29$__["exec"]);
const dynamic = 'force-dynamic';
const runtime = 'nodejs';
async function getNetworkStats(device) {
    try {
        const [rxBytes, txBytes] = await Promise.all([
            execAsync(`cat /sys/class/net/${device}/statistics/rx_bytes`),
            execAsync(`cat /sys/class/net/${device}/statistics/tx_bytes`)
        ]);
        return {
            rxBytes: parseInt(rxBytes.stdout.trim(), 10),
            txBytes: parseInt(txBytes.stdout.trim(), 10)
        };
    } catch (error) {
        throw new Error(`Failed to read stats for ${device}: ${error}`);
    }
}
async function GET(request) {
    const encoder = new TextEncoder();
    let intervalId = null;
    let isStreamActive = true;
    const lastStats = {};
    // Get list of devices
    const devices = [];
    try {
        const { stdout } = await execAsync('ls /sys/class/net');
        devices.push(...stdout.trim().split('\n').filter((dev)=>dev !== 'lo'));
    } catch (err) {
        console.error('Error getting network devices:', err);
        return new Response('Failed to get network devices', {
            status: 500
        });
    }
    const stream = new ReadableStream({
        start: async (controller)=>{
            try {
                // Handle client disconnection
                request.signal.addEventListener('abort', ()=>{
                    console.log('Client disconnected, cleaning up');
                    isStreamActive = false;
                    if (intervalId) {
                        clearInterval(intervalId);
                        intervalId = null;
                    }
                    controller.close();
                });
                // Initialize last stats
                for (const device of devices){
                    try {
                        const stats = await getNetworkStats(device);
                        lastStats[device] = {
                            ...stats,
                            timestamp: Date.now()
                        };
                    } catch (error) {
                        console.error(`Error initializing stats for ${device}:`, error);
                    }
                }
                // Set up interval for data collection
                intervalId = setInterval(async ()=>{
                    if (!isStreamActive) {
                        if (intervalId) {
                            clearInterval(intervalId);
                            intervalId = null;
                        }
                        return;
                    }
                    // Collect data for all devices
                    for (const device of devices){
                        try {
                            const now = Date.now();
                            const stats = await getNetworkStats(device);
                            const last = lastStats[device];
                            if (last) {
                                const timeDiff = (now - last.timestamp) / 1000; // Convert to seconds
                                const rxDiff = stats.rxBytes - last.rxBytes;
                                const txDiff = stats.txBytes - last.txBytes;
                                // Calculate KB/s
                                const kbIn = rxDiff / 1024 / timeDiff;
                                const kbOut = txDiff / 1024 / timeDiff;
                                if (!isNaN(kbIn) && !isNaN(kbOut)) {
                                    const data = {
                                        timestamp: new Date().toLocaleTimeString(),
                                        kbIn,
                                        kbOut,
                                        device
                                    };
                                    // Only send data if the stream is still active
                                    if (isStreamActive) {
                                        try {
                                            // Send data
                                            controller.enqueue(encoder.encode(`data: ${JSON.stringify(data)}\n\n`));
                                        } catch (error) {
                                            console.log(`Stream closed, stopping data collection:`, error);
                                            isStreamActive = false;
                                            if (intervalId) {
                                                clearInterval(intervalId);
                                                intervalId = null;
                                            }
                                            return;
                                        }
                                    }
                                }
                            }
                            // Update last stats
                            lastStats[device] = {
                                ...stats,
                                timestamp: now
                            };
                        } catch (error) {
                            console.error(`Error collecting data for ${device}:`, error);
                            if (isStreamActive) {
                                try {
                                    controller.enqueue(encoder.encode(`event: error\ndata: ${JSON.stringify({
                                        error: String(error),
                                        device
                                    })}\n\n`));
                                } catch (enqueueError) {
                                    console.log('Stream closed during error handling:', enqueueError);
                                    isStreamActive = false;
                                    if (intervalId) {
                                        clearInterval(intervalId);
                                        intervalId = null;
                                    }
                                    return;
                                }
                            }
                        }
                    }
                    // Send heartbeat every 30 seconds
                    if (isStreamActive && Date.now() % 30000 < 1000) {
                        try {
                            controller.enqueue(encoder.encode('event: heartbeat\ndata: {}\n\n'));
                        } catch (enqueueError) {
                            console.log('Stream closed during heartbeat:', enqueueError);
                            isStreamActive = false;
                            if (intervalId) {
                                clearInterval(intervalId);
                                intervalId = null;
                            }
                        }
                    }
                }, 1000);
            } catch (error) {
                console.error('Stream setup error:', error);
                isStreamActive = false;
                if (intervalId) {
                    clearInterval(intervalId);
                    intervalId = null;
                }
                controller.error(error);
            }
        },
        cancel: ()=>{
            console.log('Stream cancelled');
            isStreamActive = false;
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;
            }
        }
    });
    return new Response(stream, {
        headers: {
            'Content-Type': 'text/event-stream',
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive'
        }
    });
}
}}),
"[project]/ (server-utils)": ((__turbopack_context__) => {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
}}),

};

//# sourceMappingURL=%5Broot%20of%20the%20server%5D__070488._.js.map